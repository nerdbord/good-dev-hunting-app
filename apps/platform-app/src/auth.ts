import { prisma } from '@/lib/prismaClient'
import { PrismaAdapter } from '@auth/prisma-adapter'
import NextAuth, { type AdapterUser } from 'next-auth'
import { type JWT } from 'next-auth/jwt'
import Email from 'next-auth/providers/email'
import Github, { type GitHubProfile } from 'next-auth/providers/github'
import LinkedIn, { type LinkedInProfile } from 'next-auth/providers/linkedin'
import { findUserById } from './app/[locale]/(auth)/_actions'
import { createGitHubDetailsForUser } from './backend/github-details/github-details.service'
import { sendMagicLinkEmail } from './backend/mailing/mailing.service'
import { AppRoutes } from './utils/routes'

const sendVerificationRequest = async ({
  url, // magic link
  identifier, // user email
}: {
  url: string
  identifier: string
}) => {
  try {
    await sendMagicLinkEmail(identifier, url)
  } catch (error) {
    throw new Error('Failed to send verification email.')
  }
}

export const {
  handlers: { GET, POST },
  auth,
  signIn,
  signOut,
} = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: 'jwt',
  },
  providers: [
    LinkedIn({
      clientId: process.env.LINKEDIN_CLIENT_ID,
      clientSecret: process.env.LINKEDIN_CLIENT_SECRET,
      allowDangerousEmailAccountLinking: true,
      profile: (profile: LinkedInProfile): AdapterUser => {
        return {
          id: profile.sub.toString(),
          email: profile.email,
          avatarUrl: profile.picture,
        }
      },
    }),
    Github({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET,
      allowDangerousEmailAccountLinking: true,
      profile: (profile: GitHubProfile): AdapterUser => {
        return {
          id: profile.id.toString(),
          email: profile.email as AdapterUser['email'],
          avatarUrl: profile.avatar_url,
        }
      },
    }),
    Email({
      sendVerificationRequest,

      // if deleted, throws error
      server: {
        host: process.env.EMAIL_SERVER_HOST,
        port: process.env.EMAIL_SERVER_PORT,
        auth: {
          user: process.env.EMAIL_SERVER_USER,
          pass: process.env.EMAIL_SERVER_PASSWORD,
        },
      },
      from: process.env.EMAIL_FROM,
    }),
  ],
  pages: {
    // must be named like this - otherwise throws error when route with search params
    signIn: AppRoutes.signIn,
    error: AppRoutes.error,
  },

  callbacks: {
    async jwt({ token, user, account, profile }) {
      try {
        if (user) {
          token = {
            ...token,
            id: user.id as JWT['id'],
            email: user.email as JWT['email'],
            avatarUrl: user.avatarUrl || null,
            name: profile?.name || null,
            githubUsername: (profile?.login as JWT['githubUsername']) || null,
            provider: account?.provider as JWT['provider'],

            // @ts-expect-error - user.roles exist because it is autogenerated by prisma
            roles: user.roles as JWT['roles'],
          }
        } else {
          const foundUser = await findUserById(token.id)
          if (foundUser) {
            token = {
              ...token,
              id: foundUser.id,
              email: foundUser.email,
              avatarUrl: foundUser.avatarUrl,
              roles: foundUser.roles,
              githubUsername: foundUser.githubUsername,
              profileId: foundUser.profileId,
            }
          }
        }
      } catch (error) {
        console.error('Error in JWT callback:', error)
        await signOut()
      }

      return token
    },
    session({ session, token }) {
      // @ts-expect-error - emailVerified is redundant
      session.user = {
        id: token.id,
        email: token.email,
        avatarUrl: token.avatarUrl,
        name: token.name,
        roles: token.roles,
        githubUsername: token.githubUsername,
        profileId: token.profileId,
      }

      return {
        ...session,
        provider: token.provider,
      }
    },
  },
  events: {
    async signIn({ user, account, profile }) {
      if (user.id && account?.provider && profile) {
        if (account.provider === 'github') {
          await createGitHubDetailsForUser(
            user.id,
            profile.login as GitHubProfile['login'],
          )
        }
      }
    },
  },
})
