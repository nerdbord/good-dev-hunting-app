import { prisma } from '@/lib/prismaClient'
import { PrismaAdapter } from '@auth/prisma-adapter'
import NextAuth, { type AdapterUser } from 'next-auth'
import { type JWT } from 'next-auth/jwt'
import Email from 'next-auth/providers/email'
import Github, { type GitHubProfile } from 'next-auth/providers/github'
import LinkedIn, { type LinkedInProfile } from 'next-auth/providers/linkedin'
import { findUserById } from './app/[locale]/(auth)/_actions'
import { createGitHubDetailsForUser } from './backend/github-details/github-details.service'
import { sendMagicLinkEmail } from './backend/mailing/mailing.service'
import { AppRoutes } from './utils/routes'

const sendVerificationRequest = async ({
  url, // magic link
  identifier, // user email
}: {
  url: string
  identifier: string
}) => {
  try {
    await sendMagicLinkEmail(identifier, url)
  } catch (error) {
    throw new Error('Failed to send verification email.')
  }
}

export const {
  handlers: { GET, POST },
  auth,
  signIn,
  signOut,
} = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: 'jwt',
  },
  providers: [
    LinkedIn({
      clientId: process.env.LINKEDIN_CLIENT_ID,
      clientSecret: process.env.LINKEDIN_CLIENT_SECRET,
      allowDangerousEmailAccountLinking: true,
      profile: (profile: LinkedInProfile): AdapterUser => {
        return {
          id: profile.sub.toString(),
          email: profile.email,
          avatarUrl: profile.picture,
        }
      },
    }),
    Github({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET,
      allowDangerousEmailAccountLinking: true,
      profile: (profile: GitHubProfile): AdapterUser => {
        return {
          id: profile.id.toString(),
          email: profile.email as AdapterUser['email'],
          avatarUrl: profile.avatar_url,
        }
      },
    }),
    Email({
      sendVerificationRequest,

      // if deleted, throws error
      server: {
        host: process.env.EMAIL_SERVER_HOST,
        port: process.env.EMAIL_SERVER_PORT,
        auth: {
          user: process.env.EMAIL_SERVER_USER,
          pass: process.env.EMAIL_SERVER_PASSWORD,
        },
      },
      from: process.env.EMAIL_FROM,
    }),
  ],
  pages: {
    // must be named like this - otherwise throws error when route with search params
    signIn: AppRoutes.signIn,
    error: AppRoutes.error,
  },

  callbacks: {
    async jwt({ token, user, account, profile, trigger, session }) {
      try {
        if (trigger === 'signUp' && user) {
          // Create token during sign-up, include profile data if available
          token = {
            ...token,
            id: user.id as JWT['id'],
            email: user.email as JWT['email'],
            avatarUrl: user.avatarUrl || null,
            name: profile?.name || null,
            githubUsername: (profile?.login as JWT['githubUsername']) || null,
            provider: account?.provider as JWT['provider'],
            profileId: null,
            profileSlug: null,

            // @ts-expect-error - user.roles exist because it is autogenerated by prisma
            roles: user.roles,
          }
        } else if (trigger === 'signIn' && user.id) {
          // Fetch the latest user data from the database on sign-in
          const foundUser = await findUserById(user.id)
          if (foundUser) {
            token = {
              ...token,
              id: foundUser.id,
              email: foundUser.email,
              avatarUrl: foundUser.avatarUrl,
              name: foundUser.name || profile?.name || null,
              roles: foundUser.roles,
              githubUsername: foundUser.githubUsername,
              profileId: foundUser.profileId,
              profileSlug: foundUser.profileSlug,

              // Fetch provider name on signIn
              provider: account?.provider as JWT['provider'],
            }
          }
        } else if (trigger === 'update' && session?.user) {
          // Update token based on session updates from the client

          token = {
            ...token,
            avatarUrl: session.user.avatarUrl,
            name: session.user.name,
            profileId: session.user.profileId,
            profileSlug: session.user.profileSlug,
            // add more fields here if needed in future to do an update through useSession().update
          }
        } else {
          // For other calls, use the token as is (skip unnecessary DB calls)

          if (token.roles.length === 1) {
            // Update roles if there is no updated roles on signUp
            // (we can't update roles through session update in server component)
            // this is a workaround for now
            const foundUser = await findUserById(token.id)
            if (foundUser) {
              token = {
                ...token,
                roles: foundUser.roles,
              }
            }
          }
        }
      } catch (error) {
        console.error('auth.ts - Error in JWT callback:', error)
        return null
      }

      return token
    },
    session({ session, token }) {
      // @ts-expect-error - emailVerified is redundant
      session.user = {
        id: token.id,
        email: token.email,
        avatarUrl: token.avatarUrl,
        name: token.name,
        roles: token.roles,
        githubUsername: token.githubUsername,
        profileId: token.profileId,
        profileSlug: token.profileSlug,
      }
      session.provider = token.provider

      return session
    },
  },
  events: {
    async signIn({ user, account, profile }) {
      if (user.id && account?.provider && profile) {
        if (account.provider === 'github') {
          await createGitHubDetailsForUser(
            user.id,
            profile.login as GitHubProfile['login'],
          )
        }
      }
    },
  },
})
